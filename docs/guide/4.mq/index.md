---
title: 消息队列
order: 4
---

# 消息队列

**消息队列（Message Queue，简称 MQ）** 是一种 **异步通信机制**，主要用于系统之间 **解耦、削峰、异步处理** 等场景。它的核心理念是：

* **生产者（Producer）**：发送消息到队列；
* **消费者（Consumer）**：从队列中接收并处理消息；
* **消息中间件（Broker）**：存储、路由、转发消息。

---

## 一、消息队列的作用

1. **解耦**：系统之间不需要直接调用，通过 MQ 解耦业务模块。
2. **削峰填谷**：应对高并发，防止系统因突发流量崩溃。
3. **异步处理**：加快响应速度，如下单后发短信异步执行。
4. **可靠通信**：确保消息最终被消费（支持事务/重试机制）。
5. **广播/订阅模型**：一条消息可被多个消费者接收。

---

## 二、主流 MQ 对比

| 特性         | **RocketMQ** | **Kafka**       | **RabbitMQ** | **ActiveMQ** | **Redis MQ**             |
| ---------- | ------------ | --------------- | ------------ | ------------ | ------------------------ |
| **开发语言**   | Java         | Scala/Java      | Erlang       | Java         | C                        |
| **消息协议**   | 自定义          | 自定义             | AMQP         | JMS          | 自定义（或Stream/StreamGroup） |
| **吞吐量**    | 高            | 极高              | 中等           | 中            | 中等偏高                     |
| **延迟**     | 低            | 低（但有批量）         | 非常低          | 一般           | 低                        |
| **可靠性**    | 高            | 高（副本、确认）        | 高            | 一般           | 中                        |
| **消息顺序**   | 支持（顺序消费）     | 分区顺序            | 队列顺序         | 队列顺序         | 基于 List 顺序               |
| **消息堆积能力** | 强（TB 级别）     | 极强（Kafka 专为大数据） | 中            | 较差（不适合大量积压）  | 弱（内存为主）                  |
| **消费模型**   | 多种（推/拉）      | 拉模式             | 推模式          | 推模式          | 拉模式（订阅机制）                |
| **事务支持**   | 强（事务消息）      | 较弱（依赖幂等）        | 无            | 有            | 无（需业务保证）                 |
| **持久化机制**  | 磁盘           | 磁盘 + 顺序写优化      | 磁盘（持久化可选）    | 磁盘           | 内存为主，RDB/AOF 辅助          |
| **适用场景**   | 企业消息、金融、交易   | 日志、流式处理、大数据     | 实时任务、消息分发    | 简单企业系统       | 小系统通知、轻量消息队列             |

---

## 三、使用场景举例

* **RocketMQ**：

  * 优点：事务消息、可靠性高、吞吐高、支持顺序消费。
  * 适用：订单处理、交易系统、支付宝/淘宝内部大量使用。

* **Kafka**：

  * 优点：极高吞吐量、分布式、高可用、数据可追溯。
  * 适用：日志采集、行为分析、实时流处理（配合 Flink、Spark）。

* **RabbitMQ**：

  * 优点：支持多种协议（AMQP），插件丰富，易用。
  * 适用：小型系统、实时通知（如注册发送短信/邮件）。

* **ActiveMQ**：

  * 优点：JMS 支持好，老牌 Java 系统的集成良好。
  * 适用：Java EE 项目、老旧系统维护。

* **Redis MQ（Stream / List 实现）**：

  * 优点：部署简单，轻量级，支持持久化。
  * 适用：轻量级异步任务、小系统通知、延时队列。

---

## 四、总结建议

| 需求                | 推荐 MQ    |
| ----------------- | -------- |
| 高吞吐、大数据日志         | Kafka    |
| 金融级事务、顺序消息        | RocketMQ |
| 轻量级服务间通信、Web 实时交互 | RabbitMQ |
| Java 老系统          | ActiveMQ |
| 小型服务、已部署 Redis 环境 | Redis MQ |

---
