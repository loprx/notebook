---
title: 锁
order: 2
---

# 锁

锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 锁的粒度

### 全局锁

> 锁定数据库中的所有表
>

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。

其典型的使用场景是做**全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

为了防止在备份过程中数据被更新，所以备份时候要加锁。加锁以后只能查询，不能写入。

```sql
// 添加全局锁
flush tables with read lock;
```

```sql
unlock tables;
```

### 表级锁

> 每次操作锁住整张表
>

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MylSAM、InnoDB、BDB等存储引擎中。

#### 表锁

##### 表共享读锁

**共享锁**（share lock）：**共享锁又称读锁**，简称 S 锁；当一个事务为数据加上读锁本后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现**重复读**的问题。

```sql
lock tables tab_name... read;
```

```sql
unlock tables;
```

##### 表独占写锁

**排他锁又称写锁**，简称 X 锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取，避免了出现**脏数据和脏读**的问题。

```sql
lock tables tab_name... write;
```

#### 元数据锁( meta data lock，MDL)

MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免 DML 与 DDL 冲突，保证读写的正确性。

在 MySQL5.5 中引入了 MDL，当对一张表进行增删改查的时候，加 MDL 读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。

| **对应SQL** | **锁类型** | **说明** |
| --- | --- | --- |
| lock tables xxx read/write | shared_read_only / shared_no_read_write | |
| select select ... lock in share mode | shared_read | 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE |
| insert update delete select ... for update | shared_write | 互斥与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 |
| alter table ... | exclusive | 与其他的MDL都互斥 |

```sql
select object_type,object_schema,object_name,lock_type,lock_duration 
from performance_schema.metadata_locks ;
```

#### 意向锁

为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。

如果事物 A 提交了一个行锁，同时还会标记一个意向锁，当事物 B 进入时，需要**表加锁**时，会判断加入的锁和意向锁是否一致。

1. 意向共享锁（IS）：由语句 select ... lock in share mode 添加
    1. 与表锁共享锁( read）兼容，与表锁排它锁( write）互斥
2. 意向排他锁（IX）：由 insert、update、delete、select ... for update 添加
    1. 与表锁共享锁(read）及排它锁（ write）都互斥。意向锁之间不会互斥

```sql
select object_schema,object_name,index_name,lock_type.lock_mode,lock_data from performance_schema.data_locks;
```

### 行级锁

> 每次操作锁住对应的行数据
>

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。

InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

#### 行锁

```sql
-- 行锁一定是索引字段，否则会升级成表锁 
-- 排它锁
select * from tb_name where id=1 for update;

-- 共享读锁
select * from tb_name where id=1 lock in share mode;

-- insert update delete 是自动加锁
```

锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。

记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁店锁住的只是表的某一条记录，**加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，**也避免了在修改的事务未提交前被其他事务读取的脏读问题。

1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
    1. 多个事务可以加同一个共享锁
    2. 多个事务共享锁和排它锁互斥
2. 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁
    1. 多个事务，同一把排它锁互斥

![执行流程](/assets/image/3.database/1.mysql/2.lock/1.lock.png)

| SQL | 行锁类型 |
| --- | --- |
| INSERT | 排它锁 |
| UPDATE | 排它锁 |
| DELETE | 排它锁 |
| SELECT | 不加锁 |
| SELECT ... LOCK IN SHARE MODE | 共享锁 |
| SELECT ... FOR UPDATE | 排它锁 |


默认情况下，InnoDB在REPEATABLEREAD事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。

1. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
2. InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。

```sql
select object_schema,object_name,jindex_name,Jock_type,lock_mode,lock_data from performance_schema.data_locks;
```

#### 间隙锁（GAP lock）

**锁定索引记录间隙**（不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在 RR 隔离级别下都支持。

是属于行锁的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻 ID 之间出现空隙则会形成一个区间，遵循左开右闭原则。范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在 REPEATABLE_READ（重复读）的事务级别中。

默认情况下，InnoDB在REPEATABLEREAD事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以**防止幻读。**

间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，**一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。**

1. 索引上的**等值查询(唯一索引)**，给不存在的记录加锁时，优化为间隙锁。
    1. 如果数据库里面有1-4的记录，但是此时查询8的记录，这样就会触发间隙锁，同时如果插入一个值为 7 的数据也会阻塞。
2. 索引上的**等值查询(普通索引)**，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。
    1. 普通索引可能存在多个一样的数值，为了防止多个事务超它前后的位置插入值，所以会在紧邻的键上也加锁
3. 索引上的**范围查询(唯一索引)**，会访问到不满足条件的第一个值为止。
    1. 范围查询也会加临键锁
    2. 比如 查询 >= 19 的记录，**它会加正无穷大和后面的第一条记录的锁**

#### 临键锁（Next-Key lock）

行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是**记录锁和间隙锁**的组合，临键锁会把查询出来的记录锁住，同时也会把该**范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。**

> 基于锁的属性分类：共享锁、排它锁
>
> 基于锁的粒度分类：行级锁（InnoDB）、表级锁（InnoDB、MyISAM）、页级锁（InnoDB）、记录锁、间隙锁、临键锁
>
> 基于锁的状态分类：意向共享锁、意向排它锁
>

**共享锁**（share lock）：**共享锁又称读锁**，简称S锁；当一个事务为数据加上读锁本后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现**重复读**的问题。

**排它锁**（exclusive lock）：**排他锁又称写锁**，简称 X 锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取，避免了出现**脏数据和脏读**的问题。

**表锁**（table lock）：表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问;特点:粒度大，加锁简单，容易冲突；

**行锁**：行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问，特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高。

**记录锁**（Record lock）：

**页锁**：页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。特点：开销和加锁时间界于表锁和行锁之间，会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

**间隙锁**：。

**临键锁**(Next-Key lock)：也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是**记录锁和间隙锁**的组合，临键锁会把查询出来的记录锁住，同时也会把该**范围**查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。
